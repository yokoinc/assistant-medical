const express = require('express');
const session = require('express-session');
const { Pool } = require('pg');
const OpenAI = require('openai');
const helmet = require('helmet');
const rateLimit = require('express-rate-limit');
const { body, validationResult } = require('express-validator');
const multer = require('multer');
const path = require('path');
const fs = require('fs');
const bcrypt = require('bcrypt');
const { v4: uuidv4 } = require('uuid');
const moment = require('moment');

require('dotenv').config();

const app = express();
const PORT = process.env.PORT || 3000;

// Configuration pour les proxies (nginx)
app.set('trust proxy', true);

// Configuration base de donn√©es
const DB_CONFIG = {
    host: process.env.DB_HOST || 'postgres',
    user: process.env.DB_USER || 'medical_user',
    password: process.env.DB_PASS,
    database: process.env.DB_NAME || 'medical_assistant',
    port: 5432,
};

const db = new Pool(DB_CONFIG);

// Configuration OpenAI - ‚úÖ GESTION D'ERREUR AM√âLIOR√âE
let openai = null;
if (process.env.OPENAI_API_KEY) {
    try {
        openai = new OpenAI({
            apiKey: process.env.OPENAI_API_KEY,
        });
        console.log('‚úÖ OpenAI configur√©');
    } catch (error) {
        console.error('‚ùå Erreur configuration OpenAI:', error.message);
    }
} else {
    console.warn('‚ö†Ô∏è  OpenAI non configur√© - Chat d√©sactiv√©');
}

// Middleware de s√©curit√©
app.use(helmet({
    contentSecurityPolicy: {
        directives: {
            defaultSrc: ["'self'"],
            styleSrc: ["'self'", "'unsafe-inline'", "https://cdnjs.cloudflare.com"],
            scriptSrc: ["'self'", "'unsafe-inline'"],
            imgSrc: ["'self'", "data:", "blob:"],
            fontSrc: ["'self'", "https://cdnjs.cloudflare.com"],
        },
    },
}));

// Rate limiting am√©lior√©
const authLimiter = rateLimit({
    windowMs: 15 * 60 * 1000, // 15 minutes
    max: 5, // Maximum 5 tentatives par IP
    skipSuccessfulRequests: true,
    standardHeaders: true,
    legacyHeaders: false,
    message: {
        error: 'Trop de tentatives de connexion. R√©essayez dans 15 minutes.'
    }
});

// Rate limiting g√©n√©ral
const generalLimiter = rateLimit({
    windowMs: 15 * 60 * 1000, // 15 minutes
    max: 100, // Maximum 100 requ√™tes par IP
    standardHeaders: true,
    legacyHeaders: false,
});

// Rate limiting sp√©cifique pour le chat IA
const chatLimiter = rateLimit({
    windowMs: 60 * 60 * 1000, // 1 heure
    max: parseInt(process.env.CHAT_HOURLY_LIMIT) || 20, // Configurable via .env
    skipSuccessfulRequests: false,
    standardHeaders: true,
    legacyHeaders: false,
    message: {
        error: 'Limite de messages chat temporaire atteinte. R√©essayez dans 1 heure.',
        suggestion: 'Pour des questions urgentes, utilisez la messagerie priv√©e au m√©decin.'
    }
});

app.use(generalLimiter);

// Middleware Express
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));
app.use(express.static('public'));

// Configuration des sessions - ‚úÖ S√âCURIS√âE ET STABLE
app.use(session({
    secret: process.env.SESSION_SECRET || 'medical-assistant-secret-key-change-in-production',
    resave: false,
    saveUninitialized: false,
    name: 'medical_session',
    cookie: {
        secure: false, // Forc√© √† false pour tunnel Cloudflare
        httpOnly: true,
        maxAge: 24 * 60 * 60 * 1000, // 24 heures
        sameSite: 'lax'
    }
}));

// Configuration upload de fichiers
const storage = multer.diskStorage({
    destination: (req, file, cb) => {
        const uploadDir = './uploads';
        if (!fs.existsSync(uploadDir)) {
            fs.mkdirSync(uploadDir, { recursive: true });
        }
        cb(null, uploadDir);
    },
    filename: (req, file, cb) => {
        const uniqueName = `${uuidv4()}-${Date.now()}${path.extname(file.originalname)}`;
        cb(null, uniqueName);
    }
});

const upload = multer({
    storage: storage,
    limits: { fileSize: 50 * 1024 * 1024 }, // 50MB
    fileFilter: (req, file, cb) => {
        const allowedTypes = [
            'application/pdf',
            'image/jpeg',
            'image/jpg', 
            'image/png',
            'image/heic',
            'application/zip'
        ];
        cb(null, allowedTypes.includes(file.mimetype));
    }
});

// Middleware d'authentification am√©lior√©
const requireAuth = (req, res, next) => {
    if (req.session && req.session.patient && req.session.patient.id) {
        // V√©rification additionnelle de la validit√© de la session
        next();
    } else {
        console.warn('üö® Tentative d\'acc√®s non autoris√© √† l\'espace patient');
        res.status(401).json({ error: 'Authentification requise' });
    }
};

const requireAdmin = (req, res, next) => {
    if (req.session && req.session.admin && req.session.admin.id) {
        // V√©rification additionnelle de la validit√© de la session admin
        next();
    } else {
        console.warn('üö® Tentative d\'acc√®s non autoris√© √† l\'administration');
        res.status(401).json({ error: 'Authentification admin requise' });
    }
};

// Configuration ChatGPT
const MEDICAL_SYSTEM_PROMPT = `Tu es l'assistant m√©dical du Dr Gr√©gory Cuffel, m√©decin g√©n√©raliste au Havre.

R√îLE ET LIMITES :
- Tu accueilles les patients et les aides avec leurs questions g√©n√©rales
- Tu NE peux PAS remplacer une consultation m√©dicale
- Tu NE donnes PAS de diagnostic m√©dical
- Tu NE prescris PAS de m√©dicaments
- En cas d'urgence, tu diriges IMM√âDIATEMENT vers les num√©ros d'urgence

NUM√âROS D'URGENCE LE HAVRE :
- SAMU : 15
- Pompiers : 18
- Police : 17
- Urgences europ√©ennes : 112
- CHU Le Havre Urgences : 02 32 73 32 32
- M√©decins de garde : 02 35 53 10 10
- Pharmacies de garde : 3237

R√©ponds toujours en fran√ßais, de mani√®re claire et rassurante.`;

// ===== ROUTES PUBLIQUES =====

app.get('/', (req, res) => {
    res.sendFile(path.join(__dirname, 'public', 'index.html'));
});

app.get('/login', (req, res) => {
    if (req.session.patient) {
        return res.redirect('/espace-patient');
    }
    res.sendFile(path.join(__dirname, 'public', 'login.html'));
});

app.get('/api/cabinet-info', async (req, res) => {
    try {
        const cabinetInfo = {
            docteur: {
                nom: "Dr Gr√©gory Cuffel",
                specialite: "M√©decin G√©n√©raliste",
                ville: "Le Havre"
            },
            horaires: {
                "Lundi": "8h00 - 19h00",
                "Mardi": "8h00 - 19h00", 
                "Mercredi": "8h00 - 19h00",
                "Jeudi": "8h00 - 19h00",
                "Vendredi": "8h00 - 19h00",
                "Samedi": "8h00 - 12h00",
                "Dimanche": "Ferm√©"
            },
            contact: {
                telephone: "02 XX XX XX XX",
                adresse: "Adresse du cabinet, Le Havre",
                email: "contact@cabinet-cuffel.fr"
            },
            infos: {
                "Rendez-vous": "Sur rendez-vous uniquement",
                "Urgences": "Contacter le 15 (SAMU)",
                "Parking": "Parking gratuit disponible",
                "Acc√®s": "Accessible PMR"
            }
        };
        res.json(cabinetInfo);
    } catch (error) {
        console.error('Erreur info cabinet:', error);
        res.status(500).json({ error: 'Erreur serveur' });
    }
});

app.get('/api/urgences', async (req, res) => {
    try {
        const result = await db.query(
            'SELECT * FROM urgences WHERE actif = true ORDER BY type, nom'
        );
        res.json(result.rows);
    } catch (error) {
        console.error('Erreur urgences:', error);
        res.status(500).json({ error: 'Erreur serveur' });
    }
});

// ===== AUTHENTIFICATION PATIENTS =====

app.post('/api/auth', authLimiter, [
    body('nom').trim().isLength({ min: 2, max: 100 }).escape(),
    body('prenom').trim().isLength({ min: 2, max: 100 }).escape(),
    body('dateNaissance').isISO8601().toDate(),
], async (req, res) => {
    try {
        const errors = validationResult(req);
        if (!errors.isEmpty()) {
            console.warn('üö® Validation √©chou√©e pour auth patient:', errors.array());
            return res.status(400).json({ error: 'Donn√©es invalides' });
        }

        const { nom, prenom, dateNaissance } = req.body;

        console.log(`üîê Tentative de connexion patient: ${prenom} ${nom}`);

        const result = await db.query(`
            SELECT * FROM patients 
            WHERE LOWER(nom) = LOWER($1) 
            AND LOWER(prenom) = LOWER($2) 
            AND date_naissance = $3 
            AND actif = true
        `, [nom.trim(), prenom.trim(), dateNaissance]);

        if (result.rows.length === 0) {
            console.warn(`üö® Patient non trouv√©: ${prenom} ${nom} (${dateNaissance})`);
            return res.status(401).json({ 
                error: 'Patient non trouv√© dans la patient√®le du Dr Cuffel' 
            });
        }

        const patient = result.rows[0];
        const sessionToken = uuidv4();
        
        const consultation = await db.query(
            'INSERT INTO consultations (patient_id, session_token) VALUES ($1, $2) RETURNING *',
            [patient.id, sessionToken]
        );

        req.session.patient = {
            id: patient.id,
            nom: patient.nom,
            prenom: patient.prenom,
            consultationId: consultation.rows[0].id,
            sessionToken: sessionToken,
            loginTime: new Date().toISOString()
        };

        console.log(`‚úÖ Connexion patient r√©ussie: ${patient.prenom} ${patient.nom} (ID: ${patient.id})`);

        res.json({ 
            success: true, 
            patient: { nom: patient.nom, prenom: patient.prenom },
            redirect: '/espace-patient'
        });

    } catch (error) {
        console.error('‚ùå Erreur authentification patient:', error);
        res.status(500).json({ error: 'Erreur serveur' });
    }
});

// ===== ROUTES PATIENTS =====

app.get('/espace-patient', requireAuth, (req, res) => {
    res.sendFile(path.join(__dirname, 'public', 'espace-patient.html'));
});

app.get('/chat-assistant', requireAuth, (req, res) => {
    res.sendFile(path.join(__dirname, 'public', 'chat.html'));
});

app.post('/api/message-prive', requireAuth, upload.array('files', 5), async (req, res) => {
    try {
        console.log(`üìß Nouveau message priv√© de ${req.session.patient.prenom} ${req.session.patient.nom}`);

        // Validation renforc√©e
        const { sujet, message, urgence } = req.body;
        
        if (!sujet || typeof sujet !== 'string' || sujet.trim().length < 5 || sujet.trim().length > 200) {
            return res.status(400).json({ error: 'Le sujet doit contenir entre 5 et 200 caract√®res' });
        }
        
        if (!message || typeof message !== 'string' || message.trim().length < 10 || message.trim().length > 2000) {
            return res.status(400).json({ error: 'Le message doit contenir entre 10 et 2000 caract√®res' });
        }
        
        if (!urgence || !['faible', 'normale', 'elevee'].includes(urgence)) {
            return res.status(400).json({ error: 'Niveau d\'urgence invalide' });
        }

        const patientId = req.session.patient.id;
        const consultationId = req.session.patient.consultationId;

        // Ins√©rer le message
        const messageResult = await db.query(`
            INSERT INTO messages_prives (
                patient_id, consultation_id, sujet, message, niveau_urgence
            ) VALUES ($1, $2, $3, $4, $5) RETURNING id
        `, [patientId, consultationId, sujet.trim(), message.trim(), urgence]);

        const messageId = messageResult.rows[0].id;

        // Traiter les fichiers s'il y en a
        if (req.files && req.files.length > 0) {
            for (const file of req.files) {
                await db.query(`
                    INSERT INTO fichiers (
                        consultation_id, nom_original, nom_stockage, type_mime, taille_bytes
                    ) VALUES ($1, $2, $3, $4, $5)
                `, [consultationId, file.originalname, file.filename, file.mimetype, file.size]);
            }
            console.log(`üìé ${req.files.length} fichier(s) ajout√©(s) au message ${messageId}`);
        }

        console.log(`‚úÖ Message envoy√© avec succ√®s, ID: ${messageId}, Urgence: ${urgence}`);

        res.json({
            success: true,
            message: 'Message envoy√© avec succ√®s au Dr Cuffel',
            messageId: messageId
        });

    } catch (error) {
        console.error('‚ùå Erreur envoi message:', error);
        res.status(500).json({ error: 'Erreur lors de l\'envoi du message' });
    }
});

app.get('/api/mes-messages', requireAuth, async (req, res) => {
    try {
        const messages = await db.query(`
            SELECT m.*, 
                   CASE WHEN m.reponse_docteur IS NOT NULL THEN true ELSE false END as repondu
            FROM messages_prives m 
            WHERE m.patient_id = $1 
            ORDER BY m.created_at DESC 
            LIMIT 20
        `, [req.session.patient.id]);

        res.json({
            messages: messages.rows.map(msg => ({
                id: msg.id,
                sujet: msg.sujet,
                message: msg.message,
                urgence: msg.niveau_urgence,
                date: moment(msg.created_at).format('DD/MM/YYYY HH:mm'),
                repondu: msg.repondu,
                reponse: msg.reponse_docteur,
                dateReponse: msg.date_reponse ? moment(msg.date_reponse).format('DD/MM/YYYY HH:mm') : null
            }))
        });
    } catch (error) {
        console.error('Erreur r√©cup√©ration messages:', error);
        res.status(500).json({ error: 'Erreur serveur' });
    }
});

// Fonction pour v√©rifier et incr√©menter la limite quotidienne par patient
async function checkAndIncrementChatLimit(patientId, consultationId) {
    try {
        const today = new Date().toISOString().split('T')[0]; // Format YYYY-MM-DD
        
        // Utiliser UPSERT pour incr√©menter ou cr√©er l'entr√©e du jour
        const result = await db.query(`
            INSERT INTO chat_usage (patient_id, consultation_id, usage_date, message_count)
            VALUES ($1, $2, $3, 1)
            ON CONFLICT (patient_id, usage_date)
            DO UPDATE SET 
                message_count = chat_usage.message_count + 1,
                consultation_id = $2
            RETURNING message_count
        `, [patientId, consultationId, today]);
        
        const currentCount = parseInt(result.rows[0]?.message_count || 0);
        const dailyLimit = parseInt(process.env.CHAT_DAILY_LIMIT) || 40;
        
        // Retourner true si la limite est atteinte
        return currentCount > dailyLimit;
    } catch (error) {
        console.error('Erreur gestion limite chat:', error);
        return false; // En cas d'erreur, on laisse passer
    }
}

// ‚úÖ GESTION D'ERREUR AM√âLIOR√âE POUR LE CHAT
app.post('/api/chat', requireAuth, chatLimiter, async (req, res) => {
    try {
        const { message } = req.body;
        
        if (!message || typeof message !== 'string' || message.trim().length === 0) {
            return res.status(400).json({ error: 'Message vide' });
        }

        const maxLength = parseInt(process.env.CHAT_MESSAGE_MAX_LENGTH) || 300;
        if (message.length > maxLength) {
            return res.status(400).json({ error: `Message trop long (max ${maxLength} caract√®res)` });
        }

        // ‚úÖ V√âRIFIER ET INCR√âMENTER LA LIMITE QUOTIDIENNE PAR PATIENT
        const dailyLimitReached = await checkAndIncrementChatLimit(
            req.session.patient.id, 
            req.session.patient.consultationId
        );
        if (dailyLimitReached) {
            return res.status(429).json({ 
                error: 'Limite quotidienne de messages chat atteinte',
                suggestion: 'Revenez demain ou utilisez la messagerie priv√©e pour des questions importantes.'
            });
        }

        // ‚úÖ V√âRIFIER SI OPENAI EST DISPONIBLE
        if (!openai) {
            return res.status(503).json({ 
                error: 'Assistant temporairement indisponible',
                fallback: 'En cas d\'urgence, appelez le 15 (SAMU)'
            });
        }

        const consultation = await db.query(
            'SELECT conversation_history FROM consultations WHERE id = $1',
            [req.session.patient.consultationId]
        );

        let conversationHistory = consultation.rows[0]?.conversation_history || [];

        conversationHistory.push({
            role: 'user',
            content: message.trim(),
            timestamp: new Date().toISOString()
        });

        const messages = [
            { role: 'system', content: MEDICAL_SYSTEM_PROMPT },
            ...conversationHistory.slice(-10).map(msg => ({
                role: msg.role,
                content: msg.content
            }))
        ];

        const completion = await openai.chat.completions.create({
            model: 'gpt-3.5-turbo',
            messages: messages,
            max_tokens: 500,
            temperature: 0.7,
        });

        const assistantResponse = completion.choices[0].message.content;

        conversationHistory.push({
            role: 'assistant',
            content: assistantResponse,
            timestamp: new Date().toISOString()
        });

        await db.query(
            'UPDATE consultations SET conversation_history = $1, updated_at = CURRENT_TIMESTAMP WHERE id = $2',
            [JSON.stringify(conversationHistory), req.session.patient.consultationId]
        );

        res.json({
            response: assistantResponse,
            timestamp: new Date().toISOString()
        });

    } catch (error) {
        console.error('Erreur chat:', error);
        res.status(500).json({ 
            error: 'Erreur assistant',
            fallback: 'En cas d\'urgence, appelez le 15 (SAMU)'
        });
    }
});

app.post('/api/logout', (req, res) => {
    const patientInfo = req.session.patient;
    req.session.destroy((err) => {
        if (err) {
            console.error('‚ùå Erreur d√©connexion:', err);
            return res.status(500).json({ error: 'Erreur d√©connexion' });
        }
        if (patientInfo) {
            console.log(`üëã D√©connexion patient: ${patientInfo.prenom} ${patientInfo.nom}`);
        }
        res.json({ success: true, redirect: '/' });
    });
});

// ===== ROUTES ADMIN =====

app.get('/admin', (req, res) => {
    if (req.session.admin) {
        return res.redirect('/admin/dashboard');
    }
    res.sendFile(path.join(__dirname, 'public', 'admin-login.html'));
});

// ‚úÖ AUTHENTIFICATION ADMIN COMPL√àTEMENT CORRIG√âE ET S√âCURIS√âE
app.post('/api/admin/auth', authLimiter, [
    body('username')
        .trim()
        .isLength({ min: 3, max: 50 })
        .matches(/^[a-zA-Z0-9._-]+$/)
        .withMessage('Nom d\'utilisateur invalide')
        .escape(),
    body('password')
        .isLength({ min: 6, max: 200 })
        .withMessage('Mot de passe invalide'),
], async (req, res) => {
    const startTime = Date.now();
    
    try {
        // Validation des entr√©es
        const errors = validationResult(req);
        if (!errors.isEmpty()) {
            console.warn('üö® Validation √©chou√©e pour admin auth:', errors.array());
            return res.status(400).json({ 
                error: 'Donn√©es invalides',
                details: process.env.NODE_ENV === 'development' ? errors.array() : undefined
            });
        }

        const { username, password } = req.body;
        
        console.log(`üîë Tentative de connexion admin: ${username}`);

        // Recherche de l'admin avec informations d√©taill√©es
        const adminResult = await db.query(`
            SELECT id, username, password_hash, nom, prenom, specialite, email, last_login, 
                   created_at, actif
            FROM admins 
            WHERE LOWER(username) = LOWER($1) AND actif = true
        `, [username]);

        // V√©rification anti-timing attack (m√™me temps d'ex√©cution si user inexistant)
        const adminExists = adminResult.rows.length > 0;
        const admin = adminExists ? adminResult.rows[0] : null;
        
        // Hash factice pour √©viter les timing attacks
        const dummyHash = '$2b$10$abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
        const hashToCheck = adminExists ? admin.password_hash : dummyHash;
        
        let passwordValid = false;
        
        // Mots de passe en clair pour NAS peu puissant (HTTPS s√©curise la transmission)
        passwordValid = (password === hashToCheck);

        // V√©rification finale avec protection anti-timing
        const isValidLogin = adminExists && passwordValid;
        
        if (!isValidLogin) {
            // Log de s√©curit√© d√©taill√©
            const clientInfo = {
                ip: req.ip || req.connection.remoteAddress,
                userAgent: req.get('User-Agent'),
                timestamp: new Date().toISOString(),
                username: username
            };
            
            console.warn(`üö® Tentative de connexion admin √©chou√©e:`, clientInfo);
            
            // Attendre un d√©lai minimum pour √©viter les timing attacks
            const minDelay = 1000; // 1 seconde minimum
            const elapsed = Date.now() - startTime;
            const remainingDelay = Math.max(0, minDelay - elapsed);
            
            await new Promise(resolve => setTimeout(resolve, remainingDelay));
            
            return res.status(401).json({ 
                error: 'Identifiants incorrects'
            });
        }

        // Connexion r√©ussie - Mise √† jour des informations de connexion
        await db.query(
            'UPDATE admins SET last_login = CURRENT_TIMESTAMP WHERE id = $1',
            [admin.id]
        );

        // Cr√©ation de la session admin s√©curis√©e
        req.session.admin = {
            id: admin.id,
            username: admin.username,
            nom: admin.nom,
            prenom: admin.prenom,
            specialite: admin.specialite,
            loginTime: new Date().toISOString(),
            lastActivity: new Date().toISOString()
        };

        // Log de s√©curit√© pour connexion r√©ussie
        const successInfo = {
            adminId: admin.id,
            username: admin.username,
            ip: req.ip || req.connection.remoteAddress,
            userAgent: req.get('User-Agent'),
            timestamp: new Date().toISOString(),
            lastLogin: admin.last_login
        };
        
        console.log(`‚úÖ Connexion admin r√©ussie:`, successInfo);

        // Attendre le d√©lai minimum m√™me en cas de succ√®s
        const minDelay = 1000;
        const elapsed = Date.now() - startTime;
        const remainingDelay = Math.max(0, minDelay - elapsed);
        
        await new Promise(resolve => setTimeout(resolve, remainingDelay));

        res.json({ 
            success: true, 
            admin: { 
                nom: admin.nom, 
                prenom: admin.prenom, 
                specialite: admin.specialite,
                lastLogin: admin.last_login ? moment(admin.last_login).format('DD/MM/YYYY HH:mm') : null
            },
            redirect: '/admin/dashboard'
        });

    } catch (error) {
        console.error('‚ùå Erreur authentification admin:', error);
        
        // Attendre le d√©lai minimum m√™me en cas d'erreur
        const minDelay = 1000;
        const elapsed = Date.now() - startTime;
        const remainingDelay = Math.max(0, minDelay - elapsed);
        
        await new Promise(resolve => setTimeout(resolve, remainingDelay));
        
        res.status(500).json({ error: 'Erreur serveur' });
    }
});

app.get('/admin/dashboard', requireAdmin, (req, res) => {
    res.sendFile(path.join(__dirname, 'public', 'admin-dashboard.html'));
});

app.get('/admin/patients', requireAdmin, (req, res) => {
    res.sendFile(path.join(__dirname, 'public', 'admin-patients.html'));
});

app.get('/api/admin/stats', requireAdmin, async (req, res) => {
    try {
        const stats = await db.query(`
            SELECT 
                COUNT(*) as total_messages,
                COUNT(CASE WHEN lu_par_docteur = false THEN 1 END) as messages_non_lus,
                COUNT(CASE WHEN reponse_docteur IS NULL THEN 1 END) as messages_sans_reponse,
                COUNT(CASE WHEN niveau_urgence = 'elevee' THEN 1 END) as messages_urgents,
                COUNT(CASE WHEN created_at >= CURRENT_DATE THEN 1 END) as messages_aujourd_hui,
                COUNT(CASE WHEN created_at >= CURRENT_DATE - INTERVAL '7 days' THEN 1 END) as messages_semaine,
                COUNT(CASE WHEN created_at >= CURRENT_DATE - INTERVAL '30 days' THEN 1 END) as messages_mois,
                COUNT(CASE WHEN archived = true THEN 1 END) as messages_archives
            FROM messages_prives
        `);

        res.json({
            messages: stats.rows[0]
        });

    } catch (error) {
        console.error('Erreur stats admin:', error);
        res.status(500).json({ error: 'Erreur serveur' });
    }
});

app.get('/api/admin/messages', requireAdmin, async (req, res) => {
    try {
        const { status = 'all', urgence = 'all', period = 'all', limit = 50 } = req.query;
        
        let whereClause = '1=1';
        let params = [];
        
        if (status === 'unread') {
            whereClause += ' AND m.lu_par_docteur = false';
        } else if (status === 'archived') {
            whereClause += ' AND m.archived = true';
        }
        
        if (urgence !== 'all') {
            whereClause += ` AND m.niveau_urgence = $${params.length + 1}`;
            params.push(urgence);
        }

        // Filtres par p√©riode
        if (period === 'today') {
            whereClause += ' AND m.created_at >= CURRENT_DATE';
        } else if (period === 'week') {
            whereClause += ' AND m.created_at >= CURRENT_DATE - INTERVAL \'7 days\'';
        } else if (period === 'month') {
            whereClause += ' AND m.created_at >= CURRENT_DATE - INTERVAL \'30 days\'';
        }
        
        params.push(parseInt(limit) || 50);
        
        const messages = await db.query(`
            SELECT m.*, p.nom, p.prenom, p.telephone, p.email
            FROM messages_prives m
            JOIN patients p ON m.patient_id = p.id
            WHERE ${whereClause}
            ORDER BY m.created_at DESC
            LIMIT $${params.length}
        `, params);

        // R√©cup√©rer les fichiers associ√©s
        for (let message of messages.rows) {
            const fichiers = await db.query(`
                SELECT f.id, f.nom_original, f.nom_stockage, f.type_mime, f.taille_bytes
                FROM fichiers f
                WHERE f.consultation_id = $1
            `, [message.consultation_id]);
            message.fichiers = fichiers.rows;
        }

        res.json({
            messages: messages.rows.map(msg => ({
                id: msg.id,
                patient: {
                    nom: msg.nom,
                    prenom: msg.prenom,
                    telephone: msg.telephone,
                    email: msg.email
                },
                sujet: msg.sujet,
                message: msg.message,
                urgence: msg.niveau_urgence,
                lu: msg.lu_par_docteur,
                repondu: !!msg.reponse_docteur,
                reponse: msg.reponse_docteur,
                dateMessage: moment(msg.created_at).format('DD/MM/YYYY HH:mm'),
                dateReponse: msg.date_reponse ? moment(msg.date_reponse).format('DD/MM/YYYY HH:mm') : null,
                fichiers: msg.fichiers || []
            }))
        });

    } catch (error) {
        console.error('Erreur messages admin:', error);
        res.status(500).json({ error: 'Erreur serveur' });
    }
});

app.post('/api/admin/messages/:id/mark-read', requireAdmin, async (req, res) => {
    try {
        const messageId = parseInt(req.params.id);
        if (isNaN(messageId)) {
            return res.status(400).json({ error: 'ID de message invalide' });
        }

        await db.query(
            'UPDATE messages_prives SET lu_par_docteur = true WHERE id = $1',
            [messageId]
        );
        
        console.log(`‚úÖ Message ${messageId} marqu√© comme lu par ${req.session.admin.username}`);
        res.json({ success: true });
    } catch (error) {
        console.error('Erreur marquer lu:', error);
        res.status(500).json({ error: 'Erreur serveur' });
    }
});

app.post('/api/admin/messages/:id/reply', requireAdmin, [
    body('reponse').trim().isLength({ min: 10, max: 5000 }),
], async (req, res) => {
    try {
        const errors = validationResult(req);
        if (!errors.isEmpty()) {
            return res.status(400).json({ error: 'R√©ponse invalide' });
        }

        const messageId = parseInt(req.params.id);
        if (isNaN(messageId)) {
            return res.status(400).json({ error: 'ID de message invalide' });
        }

        const { reponse } = req.body;

        await db.query(`
            UPDATE messages_prives 
            SET reponse_docteur = $1, date_reponse = CURRENT_TIMESTAMP, lu_par_docteur = true
            WHERE id = $2
        `, [reponse.trim(), messageId]);

        console.log(`‚úÖ R√©ponse envoy√©e au message ${messageId} par ${req.session.admin.username}`);
        res.json({ success: true, message: 'R√©ponse envoy√©e avec succ√®s' });

    } catch (error) {
        console.error('Erreur r√©ponse message:', error);
        res.status(500).json({ error: 'Erreur serveur' });
    }
});

// API pour t√©l√©charger les fichiers
app.get('/api/admin/files/:fileId', requireAdmin, async (req, res) => {
    try {
        const fileId = parseInt(req.params.fileId);
        if (isNaN(fileId)) {
            return res.status(400).json({ error: 'ID de fichier invalide' });
        }

        const fileResult = await db.query(
            'SELECT * FROM fichiers WHERE id = $1',
            [fileId]
        );

        if (fileResult.rows.length === 0) {
            return res.status(404).json({ error: 'Fichier non trouv√©' });
        }

        const file = fileResult.rows[0];
        const filePath = path.join(__dirname, 'uploads', file.nom_stockage);

        if (!fs.existsSync(filePath)) {
            return res.status(404).json({ error: 'Fichier physique non trouv√©' });
        }

        res.setHeader('Content-Disposition', `attachment; filename="${file.nom_original}"`);
        res.setHeader('Content-Type', file.type_mime || 'application/octet-stream');
        res.sendFile(filePath);

    } catch (error) {
        console.error('Erreur t√©l√©chargement fichier:', error);
        res.status(500).json({ error: 'Erreur serveur' });
    }
});

// API pour supprimer un message
app.delete('/api/admin/messages/:id', requireAdmin, async (req, res) => {
    try {
        const messageId = parseInt(req.params.id);
        if (isNaN(messageId)) {
            return res.status(400).json({ error: 'ID de message invalide' });
        }

        // R√©cup√©rer la consultation_id du message pour trouver les fichiers
        const messageResult = await db.query(
            'SELECT consultation_id FROM messages_prives WHERE id = $1',
            [messageId]
        );

        if (messageResult.rows.length === 0) {
            return res.status(404).json({ error: 'Message non trouv√©' });
        }

        const consultationId = messageResult.rows[0].consultation_id;

        // R√©cup√©rer tous les fichiers associ√©s √† cette consultation
        const filesResult = await db.query(
            'SELECT id, nom_stockage FROM fichiers WHERE consultation_id = $1',
            [consultationId]
        );

        // Supprimer les fichiers physiques du dossier uploads
        const uploadDir = path.join(__dirname, 'uploads');
        let deletedFiles = 0;
        
        for (const file of filesResult.rows) {
            const filePath = path.join(uploadDir, file.nom_stockage);
            try {
                if (fs.existsSync(filePath)) {
                    fs.unlinkSync(filePath);
                    deletedFiles++;
                    console.log(`üìÅ Fichier supprim√©: ${file.nom_stockage}`);
                }
            } catch (fileError) {
                console.warn(`‚ö†Ô∏è Impossible de supprimer le fichier ${file.nom_stockage}:`, fileError.message);
            }
        }

        // Supprimer les enregistrements de fichiers en base
        if (filesResult.rows.length > 0) {
            await db.query('DELETE FROM fichiers WHERE consultation_id = $1', [consultationId]);
        }

        // Supprimer le message
        await db.query('DELETE FROM messages_prives WHERE id = $1', [messageId]);
        
        console.log(`üóëÔ∏è Message ${messageId} supprim√© par ${req.session.admin.username} (${deletedFiles} fichier(s) supprim√©(s))`);
        res.json({ 
            success: true, 
            deletedFiles: deletedFiles,
            message: `Message supprim√© avec ${deletedFiles} fichier(s)`
        });

    } catch (error) {
        console.error('Erreur suppression message:', error);
        res.status(500).json({ error: 'Erreur serveur' });
    }
});

// API pour archiver un message (marquer comme trait√©)
app.post('/api/admin/messages/:id/archive', requireAdmin, async (req, res) => {
    try {
        const messageId = parseInt(req.params.id);
        if (isNaN(messageId)) {
            return res.status(400).json({ error: 'ID de message invalide' });
        }

        await db.query(
            'UPDATE messages_prives SET lu_par_docteur = true, archived = true WHERE id = $1',
            [messageId]
        );
        
        console.log(`üìÅ Message ${messageId} archiv√© par ${req.session.admin.username}`);
        res.json({ success: true });

    } catch (error) {
        console.error('Erreur archivage message:', error);
        res.status(500).json({ error: 'Erreur serveur' });
    }
});

// ===== GESTION DES PATIENTS =====

// Lister tous les patients
app.get('/api/admin/patients', requireAdmin, async (req, res) => {
    try {
        const { search = '', limit = 50, offset = 0 } = req.query;
        
        let whereClause = '';
        let params = [];
        
        if (search.trim()) {
            whereClause = `WHERE (LOWER(nom) LIKE LOWER($1) OR LOWER(prenom) LIKE LOWER($1) OR telephone LIKE $1 OR email LIKE LOWER($1))`;
            params.push(`%${search.trim()}%`);
        }
        
        const countQuery = `SELECT COUNT(*) as total FROM patients ${whereClause}`;
        const totalResult = await db.query(countQuery, params);
        const total = parseInt(totalResult.rows[0].total);
        
        params.push(parseInt(limit) || 50);
        params.push(parseInt(offset) || 0);
        
        const patients = await db.query(`
            SELECT id, nom, prenom, date_naissance, telephone, email, actif, created_at
            FROM patients 
            ${whereClause}
            ORDER BY nom, prenom
            LIMIT $${params.length - 1} OFFSET $${params.length}
        `, params);

        res.json({
            patients: patients.rows.map(patient => ({
                ...patient,
                created_at: moment(patient.created_at).format('DD/MM/YYYY')
            })),
            total: total,
            limit: parseInt(limit),
            offset: parseInt(offset)
        });

    } catch (error) {
        console.error('Erreur liste patients:', error);
        res.status(500).json({ error: 'Erreur serveur' });
    }
});

// Cr√©er un nouveau patient
app.post('/api/admin/patients', requireAdmin, [
    body('nom').trim().isLength({ min: 2, max: 100 }).escape(),
    body('prenom').trim().isLength({ min: 2, max: 100 }).escape(),
    body('date_naissance').isISO8601().toDate(),
    body('telephone').optional().trim().isLength({ max: 20 }),
    body('email').optional().isEmail().normalizeEmail(),
], async (req, res) => {
    try {
        const errors = validationResult(req);
        if (!errors.isEmpty()) {
            return res.status(400).json({ error: 'Donn√©es invalides', details: errors.array() });
        }

        const { nom, prenom, date_naissance, telephone, email, actif = true } = req.body;

        // V√©rifier si le patient existe d√©j√†
        const existing = await db.query(
            'SELECT id FROM patients WHERE LOWER(nom) = LOWER($1) AND LOWER(prenom) = LOWER($2) AND date_naissance = $3',
            [nom, prenom, date_naissance]
        );

        if (existing.rows.length > 0) {
            return res.status(409).json({ error: 'Un patient avec ces informations existe d√©j√†' });
        }

        const result = await db.query(`
            INSERT INTO patients (nom, prenom, date_naissance, telephone, email, actif)
            VALUES ($1, $2, $3, $4, $5, $6)
            RETURNING id, nom, prenom
        `, [nom, prenom, date_naissance, telephone || null, email || null, actif]);

        console.log(`‚úÖ Patient cr√©√©: ${result.rows[0].prenom} ${result.rows[0].nom} (ID: ${result.rows[0].id}) par ${req.session.admin.username}`);
        
        res.json({ 
            success: true, 
            patient: result.rows[0],
            message: 'Patient cr√©√© avec succ√®s'
        });

    } catch (error) {
        console.error('Erreur cr√©ation patient:', error);
        res.status(500).json({ error: 'Erreur serveur' });
    }
});

// Modifier un patient
app.put('/api/admin/patients/:id', requireAdmin, [
    body('nom').trim().isLength({ min: 2, max: 100 }).escape(),
    body('prenom').trim().isLength({ min: 2, max: 100 }).escape(),
    body('date_naissance').isISO8601().toDate(),
    body('telephone').optional().trim().isLength({ max: 20 }),
    body('email').optional().isEmail().normalizeEmail(),
    body('actif').isBoolean(),
], async (req, res) => {
    try {
        const errors = validationResult(req);
        if (!errors.isEmpty()) {
            return res.status(400).json({ error: 'Donn√©es invalides', details: errors.array() });
        }

        const patientId = parseInt(req.params.id);
        if (isNaN(patientId)) {
            return res.status(400).json({ error: 'ID patient invalide' });
        }

        const { nom, prenom, date_naissance, telephone, email, actif } = req.body;

        const result = await db.query(`
            UPDATE patients 
            SET nom = $1, prenom = $2, date_naissance = $3, telephone = $4, email = $5, actif = $6
            WHERE id = $7
            RETURNING id, nom, prenom
        `, [nom, prenom, date_naissance, telephone || null, email || null, actif, patientId]);

        if (result.rows.length === 0) {
            return res.status(404).json({ error: 'Patient non trouv√©' });
        }

        console.log(`‚úÖ Patient modifi√©: ${result.rows[0].prenom} ${result.rows[0].nom} (ID: ${result.rows[0].id}) par ${req.session.admin.username}`);
        
        res.json({ 
            success: true, 
            patient: result.rows[0],
            message: 'Patient modifi√© avec succ√®s'
        });

    } catch (error) {
        console.error('Erreur modification patient:', error);
        res.status(500).json({ error: 'Erreur serveur' });
    }
});

// Supprimer un ou plusieurs patients
app.delete('/api/admin/patients', requireAdmin, async (req, res) => {
    try {
        const { ids } = req.body;
        
        if (!Array.isArray(ids) || ids.length === 0) {
            return res.status(400).json({ error: 'Liste d\'IDs invalide' });
        }

        // V√©rifier que tous les IDs sont des nombres
        const patientIds = ids.map(id => parseInt(id)).filter(id => !isNaN(id));
        if (patientIds.length !== ids.length) {
            return res.status(400).json({ error: 'IDs patients invalides' });
        }

        // R√©cup√©rer les noms des patients avant suppression (pour les logs)
        const patientsToDelete = await db.query(
            `SELECT id, nom, prenom FROM patients WHERE id = ANY($1)`,
            [patientIds]
        );

        // Supprimer les patients (CASCADE supprimera les relations)
        const result = await db.query(
            'DELETE FROM patients WHERE id = ANY($1) RETURNING id',
            [patientIds]
        );

        const deletedCount = result.rows.length;
        
        console.log(`üóëÔ∏è ${deletedCount} patient(s) supprim√©(s) par ${req.session.admin.username}:`);
        patientsToDelete.rows.forEach(p => {
            console.log(`   - ${p.prenom} ${p.nom} (ID: ${p.id})`);
        });

        res.json({ 
            success: true, 
            deletedCount: deletedCount,
            message: `${deletedCount} patient(s) supprim√©(s) avec succ√®s`
        });

    } catch (error) {
        console.error('Erreur suppression patients:', error);
        res.status(500).json({ error: 'Erreur serveur' });
    }
});

app.post('/api/admin/logout', requireAdmin, (req, res) => {
    const adminInfo = req.session.admin;
    req.session.destroy((err) => {
        if (err) {
            console.error('‚ùå Erreur d√©connexion admin:', err);
            return res.status(500).json({ error: 'Erreur d√©connexion' });
        }
        if (adminInfo) {
            console.log(`üëã D√©connexion admin: ${adminInfo.username}`);
        }
        res.json({ success: true, redirect: '/admin' });
    });
});

// ===== UTILITAIRES =====

app.get('/api/health', (req, res) => {
    res.json({ 
        status: 'OK', 
        timestamp: new Date().toISOString(),
        uptime: process.uptime(),
        environment: process.env.NODE_ENV || 'development'
    });
});

// ‚úÖ GESTION D'ERREURS AM√âLIOR√âE
app.use((error, req, res, next) => {
    console.error('‚ùå Erreur middleware:', error);
    
    if (error instanceof multer.MulterError) {
        if (error.code === 'LIMIT_FILE_SIZE') {
            return res.status(400).json({ error: 'Fichier trop volumineux (max 50MB)' });
        }
        if (error.code === 'LIMIT_FILE_COUNT') {
            return res.status(400).json({ error: 'Trop de fichiers (max 5)' });
        }
    }
    
    // Ne pas exposer les erreurs internes en production
    const message = process.env.NODE_ENV === 'production' ? 'Erreur serveur' : error.message;
    res.status(500).json({ error: message });
});

app.use((req, res) => {
    console.warn(`‚ùì Route non trouv√©e: ${req.method} ${req.url}`);
    res.status(404).json({ error: 'Page non trouv√©e' });
});

// Test de connexion DB - ‚úÖ GESTION D'ERREUR AM√âLIOR√âE
async function testDatabaseConnection() {
    try {
        const result = await db.query('SELECT NOW() as current_time, version() as db_version');
        console.log('‚úÖ Base de donn√©es connect√©e:', {
            time: result.rows[0].current_time,
            version: result.rows[0].db_version.split(' ')[0]
        });
        return true;
    } catch (error) {
        console.error('‚ùå Erreur DB:', error.message);
        return false;
    }
}

// ‚úÖ CR√âATION AUTOMATIQUE DE L'ADMIN DEPUIS LE .ENV
async function createAdminFromEnv() {
    try {
        console.log('üîê V√©rification/Cr√©ation de l\'admin depuis .env...');
        
        // V√©rifier d'abord si la table admins existe
        const tableCheck = await db.query(`
            SELECT EXISTS (
                SELECT FROM information_schema.tables 
                WHERE table_name = 'admins'
            );
        `);
        
        if (!tableCheck.rows[0].exists) {
            console.log('‚ö†Ô∏è Table admins non trouv√©e, skip cr√©ation admin');
            return;
        }
        
        // R√©cup√©rer les identifiants du .env ou utiliser les defaults
        const adminUsername = process.env.ADMIN_USERNAME || 'admin';
        const adminPassword = process.env.ADMIN_PASSWORD || 'changeme123';
        
        // V√©rifier si l'admin existe d√©j√†
        const existingAdmin = await db.query(
            'SELECT id, username FROM admins WHERE username = $1',
            [adminUsername]
        );
        
        if (existingAdmin.rows.length > 0) {
            console.log(`‚úÖ Admin '${adminUsername}' existe d√©j√† (ID: ${existingAdmin.rows[0].id})`);
            return;
        }
        
        // Cr√©er le nouvel admin
        console.log(`üîß Cr√©ation de l'admin '${adminUsername}'...`);
        
        const adminResult = await db.query(`
            INSERT INTO admins (username, password_hash, nom, prenom, specialite, actif)
            VALUES ($1, $2, $3, $4, $5, true)
            RETURNING id, username
        `, [
            adminUsername,
            adminPassword, // Mot de passe en clair (sera utilis√© tel quel)
            'Docteur',
            'Admin',
            'M√©decin G√©n√©raliste'
        ]);
        
        console.log(`‚úÖ Admin cr√©√© avec succ√®s: ${adminResult.rows[0].username} (ID: ${adminResult.rows[0].id})`);
        
    } catch (error) {
        console.error('‚ùå Erreur cr√©ation admin:', error.message);
        // NE PAS FAIRE CRASH LE SERVEUR - juste logger l'erreur
    }
}

// D√©marrage du serveur - ‚úÖ GESTION D'ERREUR ULTRA ROBUSTE
app.listen(PORT, '0.0.0.0', async () => {
    console.log('üè• Assistant M√©dical Dr Cuffel');
    console.log(`üöÄ Serveur d√©marr√© sur le port ${PORT}`);
    console.log(`üåç Environnement: ${process.env.NODE_ENV || 'development'}`);
    console.log(`üïê D√©marrage: ${new Date().toLocaleString('fr-FR')}`);
    
    // Test de connexion DB
    const dbConnected = await testDatabaseConnection();
    if (!dbConnected) {
        console.error('üö® ERREUR: Base de donn√©es non accessible');
        console.log('‚ö†Ô∏è Le serveur continue mais certaines fonctionnalit√©s seront limit√©es');
    } else {
        // Cr√©er l'admin depuis les variables .env
        await createAdminFromEnv();
    }

    // Cr√©er le dossier uploads
    const uploadDir = './uploads';
    try {
        if (!fs.existsSync(uploadDir)) {
            fs.mkdirSync(uploadDir, { recursive: true });
            console.log('üìÅ Dossier uploads cr√©√©');
        } else {
            console.log('üìÅ Dossier uploads OK');
        }
    } catch (uploadError) {
        console.error('‚ùå Erreur cr√©ation dossier uploads:', uploadError.message);
    }

    // V√©rifications de s√©curit√© finales
    console.log('üîç V√©rifications de s√©curit√©...');
    
    if (!process.env.SESSION_SECRET || process.env.SESSION_SECRET === 'medical-assistant-secret-key-change-in-production') {
        console.warn('‚ö†Ô∏è SESSION_SECRET par d√©faut d√©tect√© - CHANGER EN PRODUCTION !');
    }
    
    if (!process.env.DB_PASS) {
        console.warn('‚ö†Ô∏è Mot de passe DB non d√©fini - V√©rifier la configuration');
    }
    
    console.log('‚úÖ Application pr√™te et s√©curis√©e !');
    console.log(`üåê Container interne sur port ${PORT} - Acc√®s externe via nginx (port configur√© dans docker-compose.yml)`);
    console.log(`üìç URLs internes container:`);
    console.log(`   ‚Ä¢ Site: http://localhost:${PORT}`);
    console.log(`   ‚Ä¢ Patients: http://localhost:${PORT}/login`);
    console.log(`   ‚Ä¢ Admin: http://localhost:${PORT}/admin`);
    console.log(`   ‚Ä¢ Health: http://localhost:${PORT}/api/health`);
    
    console.log('üéâ Serveur compl√®tement initialis√© - Pr√™t √† recevoir des connexions');
});

// Gestion propre des arr√™ts et erreurs globales
process.on('SIGTERM', async () => {
    console.log('üìõ Signal SIGTERM re√ßu - Arr√™t propre du serveur...');
    try {
        await db.end();
        console.log('‚úÖ Connexions DB ferm√©es proprement');
    } catch (error) {
        console.error('‚ùå Erreur fermeture DB:', error.message);
    }
    process.exit(0);
});

process.on('SIGINT', async () => {
    console.log('üìõ Signal SIGINT re√ßu - Arr√™t propre du serveur...');
    try {
        await db.end();
        console.log('‚úÖ Connexions DB ferm√©es proprement');
    } catch (error) {
        console.error('‚ùå Erreur fermeture DB:', error.message);
    }
    process.exit(0);
});

// Gestion ultra robuste des erreurs non g√©r√©es
process.on('unhandledRejection', (reason, promise) => {
    console.error('‚ùå Promesse rejet√©e non g√©r√©e:', reason);
    console.error('üìç Promise:', promise);
    console.error('üìç Stack:', reason?.stack);
    // Log mais ne pas crasher le serveur
});

process.on('uncaughtException', (error) => {
    console.error('‚ùå Exception non g√©r√©e CRITIQUE:', error);
    console.error('üìç Stack:', error.stack);
    console.error('üö® Red√©marrage n√©cessaire du serveur');
    
    // Tentative de nettoyage avant arr√™t
    setTimeout(async () => {
        try {
            await db.end();
            console.log('‚úÖ Nettoyage DB effectu√© avant arr√™t');
        } catch (cleanupError) {
            console.error('‚ùå Erreur nettoyage:', cleanupError.message);
        }
        process.exit(1);
    }, 1000);
});

// Export pour les tests
module.exports = app;